@import controllers.Application.latestScaladoc

@userGuidePage("Sharing fixtures") {
<div style="text-align: left">

<h1>Sharing fixtures</h1>

<p>A test <em>fixture</em> is objects or other artifacts (such as files, sockets, database
connections, <em>etc.</em>) used by tests to do their work.
If a fixture is used by only one test method, then the definitions of the fixture objects can
be local to the method, such as the objects assigned to <code>sum</code> and <code>diff</code> in the
previous <code>ExampleSpec</code> examples. If multiple methods need to share an immutable fixture, one approach
is to assign them to instance variables.</p><p>In some cases, however, shared <em>mutable</em> fixture objects may be changed by test methods such that
they need to be recreated or reinitialized before each test. Shared resources such
as files or database connections may also need to
be created and initialized before, and cleaned up after, each test. JUnit 3 offered methods <code>setUp</code> and
<code>tearDown</code> for this purpose. In ScalaTest, you can use the <code>BeforeAndAfterEach</code> trait,
which will be described later, to implement an approach similar to JUnit's <code>setUp</code>
and <code>tearDown</code>, however, this approach usually involves reassigning <code>var</code>s or mutating objects
between tests. Before going that route, you may wish to consider some more functional approaches that
avoid side effects.</p>

<p>
Note: Although the techniques described on this page are shown with <code>FlatSpec</code> examples, the techniques can be used with any style trait.
The Scaladoc for each style trait gives corresponding examples for the other style traits.
</p>

<a name="createFixtureMethods"></a>
<h4>Calling create-fixture methods</h4>

<p>
One approach is to write one or more <em>create-fixture</em> methods
that return a new instance of a needed fixture object (or an holder object containing multiple needed fixture objects) each time it
is called. You can then call a create-fixture method at the beginning of each
test method that needs the fixture, storing the returned object or objects in local variables. Here's an example:
</p>

<p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">def</span> fixture =
    <span class="stReserved">new</span> {
      <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
      <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
    }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(f.builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(f.buffer.isEmpty)
    f.buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    <span class="stReserved">val</span> f = fixture
    f.builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(f.builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(f.buffer.isEmpty)
  }
}
</pre></p><p>The &ldquo;<code>f.</code>&rdquo; in front of each use of a fixture object provides a visual indication of which objects
are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.</p>

<a name="fixtureTraits"></a>
<h4>Instantiating fixture traits</h4>

<p>A related technique is to place
the fixture objects in a <em>fixture trait</em> and run your test code in the context of a new anonymous class instance that mixes in
the fixture trait, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">trait</span> <span class="stType">Fixture</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    <span class="stReserved">new</span> <span class="stType">Fixture</span> {
      builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
      assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
      assert(buffer.isEmpty)
      buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
    }
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    <span class="stReserved">new</span> <span class="stType">Fixture</span> {
      builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
      assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
      assert(buffer.isEmpty)
    }
  }
}
</pre></p>

<a name="oneInstancePerTest"></a>
<h4>Mixing in <code>OneInstancePerTest</code></h4>

<p>If every test method requires the same set of
mutable fixture objects, one other approach you can take is make them simply <code>val</code>s and mix in trait
<a href="@latestScaladoc/#org.scalatest.OneInstancePerTest"><code>OneInstancePerTest</code></a>.  If you mix in <code>OneInstancePerTest</code>, each test
will be run in its own instance of the <code>Suite</code>, similar to the way JUnit tests are executed. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> org.scalatest.OneInstancePerTest
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">OneInstancePerTest</span> {
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p><p>Although the create-fixture, fixture-trait, and <code>OneInstancePerTest</code> approaches take care of setting up a fixture before each
test, they don't address the problem of cleaning up a fixture after the test completes. In this situation, you'll need to either
use side effects or the <em>loan pattern</em>.</p>

<a name="beforeAndAfter"></a>
<h4>Mixing in <code>BeforeAndAfter</code></h4>

<p>One way to use side effects is to mix in the <a href="@latestScaladoc/#org.scalatest.BeforeAndAfter"><code>BeforeAndAfter</code></a> trait.
With this trait you can denote a bit of code to run before each test with <code>before</code> and/or after each test
each test with <code>after</code>, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfter
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">BeforeAndAfter</span> {
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  before {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  }
<br />  after {
    builder.clear()
    buffer.clear()
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
  }
}
</pre></p>

<a name="withFixtureNoArgTest"></a>
<h4>Overriding <code>withFixture(NoArgTest)</code></h4>

<p>An alternate way to take care of setup and cleanup via side effects
is to override <code>withFixture</code>. Trait <code>Suite</code>'s implementation of
<code>runTest</code>, which is inherited by this trait, passes a no-arg test function to <code>withFixture</code>. It is <code>withFixture</code>'s
responsibility to invoke that test function.  <code>Suite</code>'s implementation of <code>withFixture</code> simply
invokes the function, like this:</p><p><pre class="stHighlighted">
<span class="stLineComment">// Default implementation</span>
<span class="stReserved">protected</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
  test()
}
</pre></p><p>You can, therefore, override <code>withFixture</code> to perform setup before, and cleanup after, invoking the test function. If
you have cleanup to perform, you should invoke the test function
inside a <code>try</code> block and perform the cleanup in a <code>finally</code> clause.
Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>) <span class="stLineComment">// perform setup</span>
    <span class="stReserved">try</span> {
      test() <span class="stLineComment">// invoke the test function</span>
    }
    <span class="stReserved">finally</span> {
      builder.clear() <span class="stLineComment">// perform cleanup</span>
      buffer.clear()
    }
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p><p>Note that the <a href="@latestScaladoc/#org.scalatest.Suite$NoArgTest"><code>NoArgTest</code></a> passed to <code>withFixture</code>, in addition to
an <code>apply</code> method that executes the test, also includes the test name as well as the <a href="@latestScaladoc/#org.scalatest.Suite@@configMapSection">config
map</a> passed to <code>runTest</code>. Thus you can also use the test name and configuration objects in <code>withFixture</code>.</p><p>The reason you should perform cleanup in a <code>finally</code> clause is that <code>withFixture</code> is called by
<code>runTest</code>, which expects an exception to be thrown to indicate a failed test. Thus when you invoke
the <code>test</code> function inside <code>withFixture</code>, it may complete abruptly with an exception. The <code>finally</code>
clause will ensure the fixture cleanup happens as that exception propagates back up the call stack to <code>runTest</code>.</p>

<a name="withFixtureOneArgTest"></a>
<h4>Overriding <code>withFixture(OneArgTest)</code></h4>

<p>To use the loan pattern, you can extend <code>fixture.FlatSpec</code> (from the <code>org.scalatest.fixture</code> package) instead of
<code>FlatSpec</code>. Each test in a <code>fixture.FlatSpec</code> takes a fixture as a parameter, allowing you to pass the fixture into
the test. You must indicate the type of the fixture parameter by specifying <code>FixtureParam</code>, and implement a
<code>withFixture</code> method that takes a <code>OneArgTest</code>. This <code>withFixture</code> method is responsible for
invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
the fixture into the test function. Here's an example:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.fixture
<span class="stReserved">import</span> java.io.FileWriter
<span class="stReserved">import</span> java.io.File
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">fixture.FlatSpec</span> {
<br />  <span class="stReserved">final</span> <span class="stReserved">val</span> tmpFile = <span class="stQuotedString">&quot;temp.txt&quot;</span>
<br />  <span class="stReserved">type</span> <span class="stType">FixtureParam</span> = <span class="stType">FileWriter</span>
<br />  <span class="stReserved">def</span> withFixture(test: <span class="stType">OneArgTest</span>) {
<br />    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(tmpFile) <span class="stLineComment">// set up the fixture</span>
    <span class="stReserved">try</span> {
      test(writer) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> {
      writer.close() <span class="stLineComment">// clean up the fixture</span>
    }
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in { writer =&gt;
    writer.write(<span class="stQuotedString">&quot;Hello, test!&quot;</span>)
    writer.flush()
    assert(<span class="stReserved">new</span> <span class="stType">File</span>(tmpFile).length === <span class="stLiteral">12</span>)
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in { writer =&gt;
    writer.write(<span class="stQuotedString">&quot;Hi, test!&quot;</span>)
    writer.flush()
    assert(<span class="stReserved">new</span> <span class="stType">File</span>(tmpFile).length === <span class="stLiteral">9</span>)
  }
}
</pre></p><p>For more information, see the <a href="@latestScaladoc/#org.scalatest.fixture.FlatSpec">documentation for <code>fixture.FlatSpec</code></a>.</p>

<a name="differentFixtures"></a>
<h4> Providing different fixtures to different tests</h4>

<p>If different tests in the same <code>FlatSpec</code> require different fixtures, you can combine the previous techniques and
provide each test with just the fixture or fixtures it needs. Here's an example in which a <code>StringBuilder</code> and a
<code>ListBuffer</code> are provided via fixture traits, and file writer (that requires cleanup) is provided via the loan pattern:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> java.io.FileWriter
<span class="stReserved">import</span> java.io.File
<span class="stReserved">import</span> collection.mutable.ListBuffer
<span class="stReserved">import</span> org.scalatest.FlatSpec
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> {
<br />  <span class="stReserved">final</span> <span class="stReserved">val</span> tmpFile = <span class="stQuotedString">&quot;temp.txt&quot;</span>
<br />  <span class="stReserved">trait</span> <span class="stType">Builder</span> {
    <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
  }
<br />  <span class="stReserved">trait</span> <span class="stType">Buffer</span> {
    <span class="stReserved">val</span> buffer = <span class="stType">ListBuffer</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>)
  }
<br />  <span class="stReserved">def</span> withWriter(testCode: <span class="stType">FileWriter</span> =&gt; <span class="stType">Any</span>) {
    <span class="stReserved">val</span> writer = <span class="stReserved">new</span> <span class="stType">FileWriter</span>(tmpFile) <span class="stLineComment">// set up the fixture</span>
    <span class="stReserved">try</span> {
      testCode(writer) <span class="stLineComment">// &quot;loan&quot; the fixture to the test</span>
    }
    <span class="stReserved">finally</span> {
      writer.close() <span class="stLineComment">// clean up the fixture</span>
    }
  }
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be productive&quot;</span> in { <span class="stLineComment">// This test needs the StringBuilder fixture</span>
    <span class="stReserved">new</span> <span class="stType">Builder</span> {
      builder.append(<span class="stQuotedString">&quot;productive!&quot;</span>)
      assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is productive!&quot;</span>)
    }
  }
<br />  it should <span class="stQuotedString">&quot;be readable&quot;</span> in { <span class="stLineComment">// This test needs the ListBuffer[String] fixture</span>
    <span class="stReserved">new</span> <span class="stType">Buffer</span> {
      buffer += (<span class="stQuotedString">&quot;readable!&quot;</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;readable!&quot;</span>))
    }
  }
<br />  it should <span class="stQuotedString">&quot;be user-friendly&quot;</span> in { <span class="stLineComment">// This test needs the FileWriter fixture</span>
    withWriter { writer =&gt;
      writer.write(<span class="stQuotedString">&quot;Hello, user!&quot;</span>)
      writer.flush()
      assert(<span class="stReserved">new</span> <span class="stType">File</span>(tmpFile).length === <span class="stLiteral">12</span>)
    }
  }
<br />  <span class="stQuotedString">&quot;Test code&quot;</span> should <span class="stQuotedString">&quot;be clear and concise&quot;</span> in { <span class="stLineComment">// This test needs the StringBuilder and ListBuffer</span>
    <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
      builder.append(<span class="stQuotedString">&quot;clear!&quot;</span>)
      buffer += (<span class="stQuotedString">&quot;concise!&quot;</span>)
      assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is clear!&quot;</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;concise!&quot;</span>))
    }
  }
<br />  it should <span class="stQuotedString">&quot;be composable&quot;</span> in { <span class="stLineComment">// This test needs all three fixtures</span>
    <span class="stReserved">new</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
      builder.append(<span class="stQuotedString">&quot;clear!&quot;</span>)
      buffer += (<span class="stQuotedString">&quot;concise!&quot;</span>)
      assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is clear!&quot;</span>)
      assert(buffer === <span class="stType">List</span>(<span class="stQuotedString">&quot;ScalaTest&quot;</span>, <span class="stQuotedString">&quot;is&quot;</span>, <span class="stQuotedString">&quot;concise!&quot;</span>))
      withWriter { writer =&gt;
        writer.write(builder.toString)
        writer.flush()
        assert(<span class="stReserved">new</span> <span class="stType">File</span>(tmpFile).length === <span class="stLiteral">19</span>)
      }
    }
  }
}
</pre></p><p>In the previous example, <code>ScalaTest should be productive</code> uses only the <code>StringBuilder</code> fixture, so it just instantiates
a <code>new Builder</code>, whereas <code>it should be readable</code> uses only the <code>ListBuffer</code> fixture, so it just intantiates
a <code>new Buffer</code>. <code>it should be user-friendly</code> needs just the <code>FileWriter</code> fixture, so it invokes
<code>withWriter</code>, which prepares and passes a <code>FileWriter</code> to the test (and takes care of closing it afterwords).</p><p>Two tests need multiple fixtures: <code>Test code should be clear and concise</code> needs both the <code>StringBuilder</code> and the
<code>ListBuffer</code>, so it instantiates a class that mixes in both fixture traits with <code>new Builder with Buffer</code>.
<code>it should be composable</code> needs all three fixtures, so in addition to <code>new Builder with Buffer</code> it also invokes
<code>withWriter</code>, wrapping just the of the test code that needs the fixture.</p><p>Note that in this case, the loan pattern is being implemented via the <code>withWriter</code> method that takes a function, not
by overriding <code>fixture.FlatSpec</code>'s <code>withFixture(OneArgTest)</code> method. <code>fixture.FlatSpec</code> makes the most sense
if all (or at least most) tests need the same fixture, whereas in this <code>Suite</code> only two tests need the
<code>FileWriter</code>.</p><p>In the previous example, the <code>withWriter</code> method passed an object into
the tests. Passing fixture objects into tests is generally a good idea when possible, but sometimes a side affect is unavoidable.
For example, if you need to initialize a database running on a server across a network, your with-fixture
method will likely have nothing to pass. In such cases, simply create a with-fixture method that takes a by-name parameter and
performs setup and cleanup via side effects, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">def</span> withDataInDatabase(test: =&gt; <span class="stType">Any</span>) {
  <span class="stLineComment">// initialize the database across the network</span>
  <span class="stReserved">try</span> {
    test <span class="stLineComment">// &quot;loan&quot; the initialized database to the test</span>
  }
  <span class="stReserved">finally</span> {
    <span class="stLineComment">// clean up the database</span>
  }
}
</pre></p><p>You can then use it like:</p><p><pre class="stHighlighted">
<span class="stQuotedString">&quot;A user&quot;</span> should <span class="stQuotedString">&quot;be able to log onto the system&quot;</span> in {
  withDataInDatabase {
    <span class="stLineComment">// test user logging in scenario</span>
  }
}
</pre></p>

<a name="composingFixtures"></a>
<h4> Composing stackable fixture traits</h4>

<p>In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
fixtures into traits that can be composed using the <em>stackable trait</em> pattern. This can be done, for example, by placing
<code>withFixture</code> methods in several traits, each of which call <code>super.withFixture</code>. Here's an example in
which the <code>StringBuilder</code> and <code>ListBuffer[String]</code> fixtures used in the previous examples have been
factored out into two <em>stackable fixture traits</em> named <code>Builder</code> and <code>Buffer</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> org.scalatest.AbstractSuite
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">AbstractSuite</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br />  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    }
    <span class="stReserved">finally</span> {
      builder.clear()
    }
  }
}
<br /><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">AbstractSuite</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">abstract</span> <span class="stReserved">override</span> <span class="stReserved">def</span> withFixture(test: <span class="stType">NoArgTest</span>) {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.withFixture(test) <span class="stLineComment">// To be stackable, must call super.withFixture</span>
    }
    <span class="stReserved">finally</span> {
      buffer.clear()
    }
  }
}
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p><p>By mixing in both the <code>Builder</code> and <code>Buffer</code> traits, <code>ExampleSpec</code> gets both fixtures, which will be
initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
In this case, <code>Builder</code> is &quot;super&quot; to </code>Buffer</code>. If you wanted <code>Buffer</code> to be &quot;super&quot;
to <code>Builder</code>, you need only switch the order you mix them together, like this:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example2Spec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>And if you only need one fixture you mix in only that trait:</p><p><pre class="stHighlighted">
<span class="stReserved">class</span> <span class="stType">Example3Spec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span>
</pre></p><p>Another way to create stackable fixture traits is by extending the <a href="@latestScaladoc/#org.scalatest.BeforeAndAfterEach"><code>BeforeAndAfterEach</code></a>
and/or <a href="@latestScaladoc/#org.scalatest.BeforeAndAfterAll"><code>BeforeAndAfterAll</code></a> traits.
<code>BeforeAndAfterEach</code> has a <code>beforeEach</code> method that will be run before each test (like JUnit's <code>setUp</code>),
and an <code>afterEach</code> method that will be run after (like JUnit's <code>tearDown</code>).
Similarly, <code>BeforeAndAfterAll</code> has a <code>beforeAll</code> method that will be run before all tests,
and an <code>afterAll</code> method that will be run after all tests. Here's what the previously shown example would look like if it
were rewritten to use the <code>BeforeAndAfterEach</code> methods instead of <code>withFixture</code>:</p><p><pre class="stHighlighted">
<span class="stReserved">import</span> org.scalatest.FlatSpec
<span class="stReserved">import</span> org.scalatest.BeforeAndAfterEach
<span class="stReserved">import</span> collection.mutable.ListBuffer
<br /><span class="stReserved">trait</span> <span class="stType">Builder</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> builder = <span class="stReserved">new</span> <span class="stType">StringBuilder</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> beforeEach() {
    builder.append(<span class="stQuotedString">&quot;ScalaTest is &quot;</span>)
    <span class="stReserved">super</span>.beforeEach() <span class="stLineComment">// To be stackable, must call super.beforeEach</span>
  }
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    }
    <span class="stReserved">finally</span> {
      builder.clear()
    }
  }
}
<br /><span class="stReserved">trait</span> <span class="stType">Buffer</span> <span class="stReserved">extends</span> <span class="stType">BeforeAndAfterEach</span> { <span class="stReserved">this</span>: <span class="stType">Suite</span> =&gt;
<br />  <span class="stReserved">val</span> buffer = <span class="stReserved">new</span> <span class="stType">ListBuffer[String]</span>
<br />  <span class="stReserved">override</span> <span class="stReserved">def</span> afterEach() {
    <span class="stReserved">try</span> {
      <span class="stReserved">super</span>.afterEach() <span class="stLineComment">// To be stackable, must call super.afterEach</span>
    }
    <span class="stReserved">finally</span> {
      buffer.clear()
    }
  }
}
<br /><span class="stReserved">class</span> <span class="stType">ExampleSpec</span> <span class="stReserved">extends</span> <span class="stType">FlatSpec</span> <span class="stReserved">with</span> <span class="stType">Builder</span> <span class="stReserved">with</span> <span class="stType">Buffer</span> {
<br />  <span class="stQuotedString">&quot;Testing&quot;</span> should <span class="stQuotedString">&quot;be easy&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;easy!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is easy!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;sweet&quot;</span>
  }
<br />  it should <span class="stQuotedString">&quot;be fun&quot;</span> in {
    builder.append(<span class="stQuotedString">&quot;fun!&quot;</span>)
    assert(builder.toString === <span class="stQuotedString">&quot;ScalaTest is fun!&quot;</span>)
    assert(buffer.isEmpty)
    buffer += <span class="stQuotedString">&quot;clear&quot;</span>
  }
}
</pre></p><p>To get the same ordering as <code>withFixture</code>, place your <code>super.beforeEach</code> call at the end of each
<code>beforeEach</code> method, and the <code>super.afterEach</code> call at the beginning of each <code>afterEach</code>
method, as shown in the previous example. It is a good idea to invoke <code>super.afterEach</code> in a <code>try</code>
block and perform cleanup in a <code>finally</code> clause, as shown in the previous example, because this ensures the
cleanup code is performed even if <code>super.afterAll</code> throws an exception.</p><p>One difference to bear in mind between the before-and-after traits and the <code>withFixture</code> methods, is that if
a <code>withFixture</code> method completes abruptly with an exception, it is considered a failed test. By contrast, if any of the
methods on the before-and-after traits (<em>i.e.</em>, <code>before</code>  and <code>after</code> of <code>BeforeAndAfter</code>,
<code>beforeEach</code> and <code>afterEach</code> of <code>BeforeAndAfterEach</code>,
and <code>beforeAll</code> and <code>afterAll</code> of <code>BeforeAndAfterAll</code>) complete abruptly, it is considered a
failed suite, which will result in a <a href="@latestScaladoc/#org.scalatest.events.SuiteAborted"><code>SuiteAborted</code></a> event.</p>

<p>
Next, learn about <a href="/user_guide/sharing_tests">sharing tests</a>.
</p>
</div>
}
